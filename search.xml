<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git常用命令总结</title>
      <link href="/2025/04/03/2025-04-03%20Git/Git%E7%AC%94%E8%AE%B0+87aedfa8-ef68-4ff1-93ac-825d3ec14f75/"/>
      <url>/2025/04/03/2025-04-03%20Git/Git%E7%AC%94%E8%AE%B0+87aedfa8-ef68-4ff1-93ac-825d3ec14f75/</url>
      
        <content type="html"><![CDATA[<p>本文章用来记录Git常用命令,学习内容引用自<a href="https://learngitbranching.js.org/">https://learngitbranching.js.org/</a></p><ul><li><p>基础命令</p><ul><li><p>git init:初始化</p></li><li><p>git add . ：这里.代表全部文件，可以替换为实际想添加文件名</p></li><li><p>git commit:提交本次修改</p><ul><li><code>git commit --amend</code> 是 Git 的一个命令，用于修改最近一次提交（commit）</li></ul></li><li><p>git branch &lt;分支name&gt;:只创建分支但不会切换到当前分支</p><ul><li>git branch -f main HEAD~3:利用相对引用移动分支，-f为force强制</li></ul></li><li><p>git checkout  &lt;分支name&gt;:切换到目标分支</p><ul><li><p>git checkout -b <branch-name>:创建分支并直接签出</p></li><li><p>git switch:2.23版本引入了取代checkout</p></li></ul></li><li><p>git merge &lt;非当前分支且需合并分支name&gt;:合并<br>  <img src="/2025/04/03/2025-04-03%20Git/Git%E7%AC%94%E8%AE%B0+87aedfa8-ef68-4ff1-93ac-825d3ec14f75/image.png" alt="git merge bugFix"></p><p>  <img src="/2025/04/03/2025-04-03%20Git/Git%E7%AC%94%E8%AE%B0+87aedfa8-ef68-4ff1-93ac-825d3ec14f75/image1.png" alt="image.png"></p><p>  父节点向子节点merge，什么都不变，只移动分支指向</p></li><li><p>git rebase &lt;变基到目标分支&gt;:提供更线性的提交序列</p><p>  <img src="/2025/04/03/2025-04-03%20Git/Git%E7%AC%94%E8%AE%B0+87aedfa8-ef68-4ff1-93ac-825d3ec14f75/image2.png" alt="image.png"></p><p>  <img src="/2025/04/03/2025-04-03%20Git/Git%E7%AC%94%E8%AE%B0+87aedfa8-ef68-4ff1-93ac-825d3ec14f75/image3.png" alt="image.png"></p><p>  rebase之后main标签仍在原处，checkout到main再rebase可使得其编导bugFix处</p></li><li><p>git log:查看提交记录的哈希值</p></li><li><p>HEAD：对当前所在分支的符号引用，总是指向当前分支上最近一次提交记录，通常情况下是指向分支名的（如 bugFix）。</p><ul><li><p>分离HEAD：</p><p>  <img src="/2025/04/03/2025-04-03%20Git/Git%E7%AC%94%E8%AE%B0+87aedfa8-ef68-4ff1-93ac-825d3ec14f75/image4.png" alt="image.png"></p><p>  现实中C1是一串提交记录的哈希值，基于SHA-1，共40位</p></li></ul></li><li><p>相对引用：</p><ul><li><p>^:向上移动1个提交记录,可以以分支名或者HEAD为位置参照分离HEAD头：</p><p>  <img src="/2025/04/03/2025-04-03%20Git/Git%E7%AC%94%E8%AE%B0+87aedfa8-ef68-4ff1-93ac-825d3ec14f75/image5.png" alt="git checkout main^"></p></li><li><p>~<num>:向上移动多个提交记录</p><p>  <img src="/2025/04/03/2025-04-03%20Git/Git%E7%AC%94%E8%AE%B0+87aedfa8-ef68-4ff1-93ac-825d3ec14f75/image6.png" alt="git checkout HEAD~4"></p></li></ul></li><li><p>git reset &lt;某个提交记录，可用相对引用&gt;:本地撤销回溯提交</p><ul><li><p><strong><code>--soft</code>:</strong> 移动 HEAD 指针和当前分支指向指定的 commit，但是 <em>暂存区和工作目录的内容保持不变</em>。 这意味着你的修改仍然存在于你的工作目录中，并且它们仍然被 Git 跟踪（在暂存区中）。</p></li><li><p><strong><code>--mixed</code> (默认):</strong> 移动 HEAD 指针和当前分支指向指定的 commit，并且 <em>重置暂存区</em>。 这意味着你的修改仍然存在于你的工作目录中，但是它们不再被 Git 跟踪（不在暂存区中）。 你需要重新 <code>git add</code> 它们才能再次 commit。</p></li><li><p><strong><code>--hard</code>:</strong> 移动 HEAD 指针和当前分支指向指定的 commit，并且 <em>重置暂存区和工作目录</em>。 这意味着你的修改 <em>会丢失</em>，因为工作目录会被重置为指定 commit 的状态。 <strong>这个模式要非常小心使用！</strong></p></li></ul><p>  <img src="/2025/04/03/2025-04-03%20Git/Git%E7%AC%94%E8%AE%B0+87aedfa8-ef68-4ff1-93ac-825d3ec14f75/image7.png" alt="git reset HEAD~1"></p><p>  在reset后， <code>C2</code> 所做的变更还在，但是处于未加入暂存区状态。</p><p>  本地使用reset很方便，但对大家共同使用的远程分支是无效的</p></li><li><p>git revert :撤销提交(生成与历史相同的新的提交)</p><p>  <img src="/2025/04/03/2025-04-03%20Git/Git%E7%AC%94%E8%AE%B0+87aedfa8-ef68-4ff1-93ac-825d3ec14f75/image8.png" alt="image.png"></p></li><li><p>git cherry-pick &lt;提交号哈希&gt;：想将一些提交复制到当前所在的位置（<code>HEAD</code>）下面</p><p>  <img src="/2025/04/03/2025-04-03%20Git/Git%E7%AC%94%E8%AE%B0+87aedfa8-ef68-4ff1-93ac-825d3ec14f75/image9.png" alt="git cherry-pick C2 C4"></p></li><li><p>git rebase -i (interactive):交互式选择边基，弹出UI选择记录。在实际使用时，所谓的 UI 窗口一般会在文本编辑器 —— 如 Vim —— 中打开一个文件，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。</p><p>  <img src="/2025/04/03/2025-04-03%20Git/Git%E7%AC%94%E8%AE%B0+87aedfa8-ef68-4ff1-93ac-825d3ec14f75/image10.png" alt="git rebase -i HEAD~4"></p><p>  编辑后新的四个提交顺序等可以自行排布</p></li><li><p>git tag <tag-name> &lt;提交哈希，或默认HEAD&gt;:<em>永远</em>指向某个提交记录的标识，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交</p></li><li><p>git describe <ref>:<strong>描述</strong>离你最近的锚点（也就是标签);<code>&lt;ref&gt;</code> 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会使用你目前所在的位置（<code>HEAD</code>）。</p><p>  它输出的结果是这样的：</p><p>  <code>&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;</code></p><p>  <code>tag</code> 表示的是离 <code>ref</code> 最近的标签， <code>numCommits</code> 是表示这个 <code>ref</code> 与 <code>tag</code> 相差有多少个提交记录， <code>hash</code> 表示的是你所给定的 <code>ref</code> 所表示的提交记录哈希值的前几位。</p><p>  当 <code>ref</code> 提交记录上有某个标签时，则只输出标签名称</p></li></ul></li><li><p>远程命令</p><ul><li><p>git clone &lt;github仓库url&gt;</p><p>  <img src="/2025/04/03/2025-04-03%20Git/Git%E7%AC%94%E8%AE%B0+87aedfa8-ef68-4ff1-93ac-825d3ec14f75/image11.png" alt="虚线为远程仓库"></p><ul><li><p>在我们的本地仓库多了一个名为 <code>o/main</code> 的分支, 这种类型的分支就叫<strong>远程</strong>分支。由于远程分支的特性导致其拥有一些特殊属性。</p></li><li><p>远程分支反映了远程仓库(在你上次和它通信时)的<strong>状态</strong>。这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步.</p></li><li><p>远程分支有一个特别的属性，在你切换到远程分支时，自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。</p><p>  <img src="/2025/04/03/2025-04-03%20Git/Git%E7%AC%94%E8%AE%B0+87aedfa8-ef68-4ff1-93ac-825d3ec14f75/image12.png" alt="image.png"></p></li><li><p>远程分支命名规范为<code>&lt;remote name&gt;/&lt;branch name&gt;</code>，git clone时已经帮你把远程仓库的名称设置为 <code>origin</code> 了</p></li></ul></li><li><p>git fetch：拉取最新远程到本地，更新o&#x2F;main标签。但不会更新本地仓库状态和文件</p><p>  <img src="/2025/04/03/2025-04-03%20Git/Git%E7%AC%94%E8%AE%B0+87aedfa8-ef68-4ff1-93ac-825d3ec14f75/image13.png" alt="image.png"></p></li><li><p>git pull≈git fetch + git merge拉取并合并</p><ul><li>git pull –rebase:远程main领先本地o&#x2F;main，pull之后变基</li></ul></li><li><p>git push:</p><ul><li><p><em><code>git push</code> 不带任何参数时的行为与 Git 的一个名为 <code>push.default</code> 的配置有关。它的默认值取决于你正使用的 Git 的版本，但是在教程中我们使用的是 <code>upstream</code></em></p></li><li><p>git push <remote> <place>:将place分支所有提交提交到remote；此时需要确保remote place名字相同，例如git push origin&#x2F;main main</p></li><li><p>git push origin <source>:<destination>:可将来源和去向分支的名称不同</p></li></ul></li><li><p>远程跟踪修改：<code>main</code> 和 <code>o/main</code> 的关联关系就是由分支的“remote tracking”属性决定的</p><ul><li><p>git checkout -b foo o&#x2F;main:更改o&#x2F;main跟踪分支，默认为main，此处修改为foo</p></li><li><p>git branch -u o&#x2F;main foo：更改o&#x2F;main跟踪分支为main</p></li></ul></li><li></li></ul></li><li><p>实例应用</p><ul><li><p>在main中发现有bug，先debug调试，同时也添加调试语句，最终bugFix，如何直接将修改后bugFix绕过中间两个版本添加到main后。</p><p>  <img src="/2025/04/03/2025-04-03%20Git/Git%E7%AC%94%E8%AE%B0+87aedfa8-ef68-4ff1-93ac-825d3ec14f75/image14.png" alt="image.png"></p><p>  使用cherry-pick或rebase -i解决</p></li><li><p>对某个以前的提交记录进行微小调整</p><ul><li><p>法一rebase-i：</p><ul><li><p>先用 <code>git rebase -i</code> 将提交重新排序，然后把我们想要修改的提交记录挪到最前</p></li><li><p>然后用 <code>git commit --amend</code> 来进行一些小修改</p></li><li><p>接着再用 <code>git rebase -i</code> 来将他们调回原来的顺序</p></li><li><p>最后我们把 main 移到修改的最前端（用你自己喜欢的方法）</p></li></ul></li><li><p>法二cherry-pick：</p><p>  git checkout main</p><p>  $ git cherry-pick C2</p><p>  $ git commit –amend</p><p>  $ git cherry-pick C3</p></li></ul><p>  <img src="/2025/04/03/2025-04-03%20Git/Git%E7%AC%94%E8%AE%B0+87aedfa8-ef68-4ff1-93ac-825d3ec14f75/image15.png" alt="image.png"></p><p>  <img src="/2025/04/03/2025-04-03%20Git/Git%E7%AC%94%E8%AE%B0+87aedfa8-ef68-4ff1-93ac-825d3ec14f75/image16.png" alt="image.png"></p></li><li><p>你的操作基于远程旧版本修改，但远程已经更新到新版本，此时会无法push</p><p>  <img src="/2025/04/03/2025-04-03%20Git/Git%E7%AC%94%E8%AE%B0+87aedfa8-ef68-4ff1-93ac-825d3ec14f75/image17.png" alt="image.png"></p><p>  上述命令等价于git pull –rebase;git push</p><p>  <img src="/2025/04/03/2025-04-03%20Git/Git%E7%AC%94%E8%AE%B0+87aedfa8-ef68-4ff1-93ac-825d3ec14f75/image18.png" alt="image.png"></p><p>  上述命令等价于git pull;git push</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Survival Analysis</title>
      <link href="/2025/03/23/2025-03-23-Survival+Analysis/Survival+Analysis/"/>
      <url>/2025/03/23/2025-03-23-Survival+Analysis/Survival+Analysis/</url>
      
        <content type="html"><![CDATA[<p>本文章既用来测试，也用来记录大数据软件分析Project1中生存分析的Report</p><h1 id="Q2-Survival-Analysis-Report"><a href="#Q2-Survival-Analysis-Report" class="headerlink" title="Q2 Survival Analysis Report"></a>Q2 Survival Analysis Report</h1><h2 id="数据集读取与预处理"><a href="#数据集读取与预处理" class="headerlink" title="数据集读取与预处理"></a>数据集读取与预处理</h2><p>读取数据集，在本案例中Churn代表着是否流失，即生存分析中的<strong>事件（Event）</strong>，因此将其转换为布尔值，便于后续分析</p><p><img src="/2025/03/23/2025-03-23-Survival+Analysis/Survival+Analysis/image.png" alt="image.png"></p><p><img src="/2025/03/23/2025-03-23-Survival+Analysis/Survival+Analysis/image1.png" alt="image.png"></p><h2 id="Kaplan-Meier-与Log-Rank检验"><a href="#Kaplan-Meier-与Log-Rank检验" class="headerlink" title="Kaplan-Meier 与Log-Rank检验"></a>Kaplan-Meier 与Log-Rank检验</h2><p>Kaplan-Meier（K-M）方法是生存分析中估计生存函数的非参数方法，适用于处理截尾数据（如随访结束时未发生事件的个体）。其核心思想是：<strong>通过分步计算每个事件时间点的生存概率，逐步构建生存函数</strong>。</p><ul><li><p>KM模型拟合</p><p>  首先对Churn为事件E，tenure为生存时间t进行模型拟合，发现有1795个右删失的数据。</p><p>  <img src="/2025/03/23/2025-03-23-Survival+Analysis/Survival+Analysis/image2.png" alt="image.png"></p><p>  绘制KM生存曲线，展示了随时间流失情况。生存概率曲线周围的浅蓝色边界表示置信区间，区间越宽，置信度越低。如图所示，估计值的置信度随着时间轴的增加而降低。</p><p>  <img src="/2025/03/23/2025-03-23-Survival+Analysis/Survival+Analysis/image3.png" alt="image.png"></p><p>  同时我们使用median_survival_time来获取<strong>中位生存时间（Median survival time）</strong>——即有一半个体发生事件的时间，为34</p></li><li><p>Log-Rank 检验</p><p>  Log-Rank 检验是一种用于比较两组或多组生存数据分布是否存在显著差异的非参数统计方法。通过计算每组在每个时间点上的期望死亡数和实际死亡数，然后基于这些数据构建一个统计量，来检验不同组的生存分布是否相同。在零假设下，即不同组的生存分布相同，该统计量服从特定的分布（通常是卡方分布）。通过计算得到的统计量与相应分布的临界值进行比较，或者计算出对应的 P 值，来判断是否拒绝零假设。</p><p>  直观上，我们可以通过观察下方生存曲线来判断不同组的生存水平是否存在显著差异；另一方面，可以通过下方表格的p-value来判断在显著性水平α下是否拒绝零假设，而认为组间存在显著差异</p><p>  <img src="/2025/03/23/2025-03-23-Survival+Analysis/Survival+Analysis/image4.png" alt="image.png"></p><table><thead><tr><th>Covariate</th><th>Test Statistic</th><th>p-value</th><th>-log2(p)</th></tr></thead><tbody><tr><td>Gender: Female vs Male</td><td>2.038938</td><td>0.153317</td><td>2.705414</td></tr><tr><td>OnlineSecurity: No vs Yes</td><td>141.60316</td><td>1.187554e-32</td><td>106.053706</td></tr><tr><td>SeniorCitizen: 0.0 vs 1.0</td><td>0.125471</td><td>0.723174</td><td>0.467584</td></tr><tr><td>Partner: No vs Yes</td><td>135.758896</td><td>2.252911e-31</td><td>101.807981</td></tr><tr><td>Dependents: No vs Yes</td><td>35.031241</td><td>3.244576e-09</td><td>28.199323</td></tr><tr><td>PhoneService: No vs Yes</td><td>1.683709</td><td>0.194432</td><td>2.36266</td></tr><tr><td>MultipleLines: No vs No phone service</td><td>12.382712</td><td>4.333273e-04</td><td>11.172255</td></tr><tr><td>MultipleLines: No vs Yes</td><td>72.358368</td><td>1.794602e-17</td><td>55.629114</td></tr><tr><td>MultipleLines: No phone service vs Yes</td><td>1.500291</td><td>0.220626</td><td>2.180322</td></tr><tr><td>InternetService: DSL vs Fiber optic</td><td>25.172866</td><td>5.241449e-07</td><td>20.863531</td></tr><tr><td>StreamingTV: No vs Yes</td><td>12.93926</td><td>0.000322</td><td>11.601718</td></tr><tr><td>StreamingMovies: No vs Yes</td><td>17.941685</td><td>0.000023</td><td>15.422016</td></tr><tr><td>OnlineSecurity: No vs Yes</td><td>141.60316</td><td>1.187554e-32</td><td>106.053706</td></tr><tr><td>OnlineBackup: No vs Yes</td><td>189.482865</td><td>4.122979e-43</td><td>140.799221</td></tr><tr><td>DeviceProtection: No vs Yes</td><td>71.496825</td><td>2.777047e-17</td><td>54.999226</td></tr><tr><td>TechSupport: No vs Yes</td><td>90.430334</td><td>1.916059e-21</td><td>68.822348</td></tr><tr><td>PaperlessBilling: No vs Yes</td><td>8.340802</td><td>0.003876</td><td>8.011049</td></tr><tr><td>PaymentMethod: Bank transfer (automatic) vs Credit card (automatic)</td><td>0.061543</td><td>0.8040732</td><td>0.314601</td></tr><tr><td>PaymentMethod: Bank transfer (automatic) vs Electronic check</td><td>91.191889</td><td>1.303937e-21</td><td>69.377616</td></tr><tr><td>PaymentMethod: Bank transfer (automatic) vs Mailed check</td><td>43.536998</td><td>4.160192e-11</td><td>34.484559</td></tr><tr><td>PaymentMethod: Credit card (automatic) vs Electronic check</td><td>79.991082</td><td>3.761035e-19</td><td>61.205504</td></tr><tr><td>PaymentMethod: Credit card (automatic) vs Mailed check</td><td>39.684613</td><td>2.984678e-10</td><td>31.641706</td></tr><tr><td>PaymentMethod: Electronic check vs Mailed check</td><td>0.898320</td><td>0.3432326</td><td>1.542741</td></tr></tbody></table></li><li><p>提取生存概率</p><p>  完成分析后，可以提取生存概率以用于其他应用程序。这里以InternetService中的DSL为例</p><p>  <img src="/2025/03/23/2025-03-23-Survival+Analysis/Survival+Analysis/image5.png" alt="image.png"></p></li></ul><h2 id="Cox比例风险"><a href="#Cox比例风险" class="headerlink" title="Cox比例风险"></a>Cox比例风险</h2><p>与Kaplan-Meier相比，COX比例风险可用于多变量分析。Kaplan-Meier用于估计生存概率，而考克斯比例风险用于估计风险比，风险比表示两个个体（或组）之间存在的风险差异。</p><p>Cox比例风险方程由基线风险和部分风险乘积构成：</p><p>$h(t)&#x3D;h_0(t)\exp\left(\sum_{i &#x3D; 1}^{p}\beta_{i}X_{i}\right)$，</p><p>比例风险假设要求协变量的效应($\beta$)是时间独立的，即风险比在随访全程中保持稳。在Cox比例风险模型的背景下，两组之间的风险比随时间成比例。</p><ul><li><p>模型拟合与评估</p><p>  为了调用Lifelines库中Cox比例风险的函数，需要对分类列进行one-hot编码，这里手工选择了五个变量用于实现。此处要注意one-hot编码后会产生新的线性相关的列，例如Dependents_Yes和Dependents_No，所以只需选择其一即可。</p><p>  <img src="/2025/03/23/2025-03-23-Survival+Analysis/Survival+Analysis/image6.png" alt="image.png"></p><p>  在数据处理后调用相关库拟合比例风险模型，输出拟合后结果。有图片可知本库采用 Breslow 方法估计基准风险，共纳入 3351 条观测数据，观测到 1556 个事件（客户流失）。</p><p>  同时可以得到各个协变量的影响，例如有家属（Dependents_Yes&#x3D;Yes）的客户，流失风险比无家属客户低 28%（风险比 0.72）；使用 DSL 网络服务的客户，流失风险比参照组低 20%等。且所有协变量的 p 值均小于 0.005，表明其对客户流失风险的影响具有统计学显著性。</p><p>  Concordance 指数为 0.64，说明模型对客户流失与留存的区分能力处于中等水平。Partial AIC 为 22639.90，数值越小表示模型拟合效果相对越好（需结合业务场景综合判断）。似然比检验统计量为 337.77（自由度 4），对应的 $-\log2(p)$ 为 236.24，进一步验证模型整体显著性，即纳入的协变量对解释客户流失风险具有统计学意义</p><p>  <img src="/2025/03/23/2025-03-23-Survival+Analysis/Survival+Analysis/image7.png" alt="image.png"></p><p>  图中展示了不同变量的风险比（HR）及 95% 置信区间，涉及变量包括 InternetService_DSL、Dependents_Yes、TechSupport_Yes、OnlineBackup_Yes。所有变量的 HR 值均小于 1，说明：</p><p>  存在这些变量对应情况时（如使用 DSL 网络、有家属、享受技术支持、开通在线备份服务），相关风险（如客户流失风险）会降低。</p><p>  其中，OnlineBackup_Yes 的 HR 值最低，降低风险的效果最显著；TechSupport_Yes、Dependents_Yes、InternetService_DSL 也依次呈现风险降低趋势，且各变量的 95% 置信区间均未包含 1，表明结果具有统计学意义。</p><p>  <img src="/2025/03/23/2025-03-23-Survival+Analysis/Survival+Analysis/image8.png" alt="image.png"></p></li><li><p>验证比例风险假设</p><p>  首先使用统计检验方法验证比例风险假设，零假设为满足比例风险假设，由p-value可知有三个变量＜0.005由此不满足比例风险假设的需求</p><p>  <img src="/2025/03/23/2025-03-23-Survival+Analysis/Survival+Analysis/image9.png" alt="image.png"></p><p>  <img src="/2025/03/23/2025-03-23-Survival+Analysis/Survival+Analysis/image10.png" alt="image.png"></p><p>  <img src="/2025/03/23/2025-03-23-Survival+Analysis/Survival+Analysis/image11.png" alt="image.png"></p><p>  使用Schoenfield 残差图，若残差随时间无明显上升或下降趋势，散点随机分布，说明对应变量满足比例风险假设（协变量对风险的影响不随时间变化）；若残差呈现明显上升或下降趋势，说明不满足假设。图中拟合线（如黑色平滑曲线）可辅助判断趋势：若拟合线平稳，无明显斜率，支持比例风险假设；若拟合线斜率显著（上升或下降），则不满足假设。因此由图可知只有第一个变量满足假设，这与使用统计检验得到的结论相同。</p><p>  <img src="/2025/03/23/2025-03-23-Survival+Analysis/Survival+Analysis/image12.png" alt="image.png"></p><p>  最后使用Log-log Kaplan-Meier Plots方法检验，当未违反比例风险系数时，双对数图中的Kaplan-Meier曲线将呈现平行。</p><pre><code>  ![image.png](image13.png)</code></pre></li></ul><h2 id="加速失效时间"><a href="#加速失效时间" class="headerlink" title="加速失效时间"></a>加速失效时间</h2><p>加速失效时间模型（Accelerated Failure Time Model，AFT）假设协变量会按一定比例加速（或减速）个体的失效时间，核心公式体系如下：</p><p>$\ln(T) &#x3D; \mu + \sum_{i &#x3D; 1}^{p}\beta_{i}X_{i} + \epsilon$</p><p>加速因子用来衡量协变量对生存时间的影响程度，定义为：</p><p>$AF &#x3D; \frac{\exp(\mu + \boldsymbol{\beta}^T\mathbf{X}_1)}{\exp(\mu + \boldsymbol{\beta}^T\mathbf{X}_2)} &#x3D; \exp\left[ \boldsymbol{\beta}^T(\mathbf{X}_1 - \mathbf{X}_2) \right]$</p><ul><li><p>模型拟合与评估</p><p>  在进行类似前文的数据处理后，直接进行总体的模型拟合。下图得到中位生存时间为135.51。</p><p>  <img src="/2025/03/23/2025-03-23-Survival+Analysis/Survival+Analysis/image14.png" alt="image.png"></p><p>  输出模型结果，可得到各协变量系数、加速因子、p-value，以及模型拟合指标。由图可得，Concordance 指数为 <strong>0.73</strong>，表明模型对客户流失与留存的区分能力较好。AIC 值为 <strong>13,698.72</strong>，数值越小表示模型拟合效果相对更优。所有协变量的 p 值均小于 0.005，统计学显著性高。加速因子 $\exp(\text{coef}) &gt; 1$，表明对应协变量会延长客户生存时间，降低流失风险。</p><pre><code>  ![image.png](image15.png)</code></pre><p>  展示了加速失效时间（AFT）模型中各变量的 <strong>对数加速失效率（log (accelerated failure rate)）及其 95% 置信区间</strong>，置信区间不跨越 0 的变量（即所有展示的协变量）均对客户生存时间有显著影响，为模型中协变量的作用提供了直观验证，支持 “协变量显著影响客户流失风险” 的结论。</p><p>  <img src="/2025/03/23/2025-03-23-Survival+Analysis/Survival+Analysis/image16.png" alt="image.png"></p></li><li><p>模型验证</p><p>  在使用加速失效时间模型时，需要评估两个基本假设：模型是否符合<code>比例优势</code>假设，以及指定的分布是否适合此模型。两个问题分别可以通过判断图中的线是否平行和线条是否是直的来判断。由下图可见绝大部分线相对直，意味着选择log-logistic作为指定分布是一个相对合理的选择，但是大部分线都是不平行的，说明加速失效时间不适用于指定模型</p><p>  若某条曲线上升更快，说明对应特征取值的用户，其流失概率的变化速率随时间增长更明显。例如，在 <code>OnlineSecurity</code> 子图中，对比 <code>Yes</code>（橙色）和 <code>No</code>（蓝色）曲线，若某条曲线在相同对数时间下 <code>failureOdds</code> 更大，说明该群体的流失风险变化更剧烈。</p><p>  <img src="/2025/03/23/2025-03-23-Survival+Analysis/Survival+Analysis/image17.png" alt="image.png"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Survival Analysis </category>
          
          <category> Pyspark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Survival Analysis </tag>
            
            <tag> Pyspark </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
